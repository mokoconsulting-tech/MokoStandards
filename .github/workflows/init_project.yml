name: Bootstrap ProjectV2 and Define Fields

on:
  workflow_dispatch:
    inputs:
      owner_login:
        description: "GitHub org or user login (e.g., mokoconsulting-tech)"
        required: true
        default: "mokoconsulting-tech"
      project_title:
        description: "Project title"
        required: true
        default: "MokoStandards Documentation Control Register"

permissions:
  contents: read
  repository-projects: write

jobs:
  bootstrap_projectv2:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Create ProjectV2 and fields (idempotent)
        uses: actions/github-script@v7
        with:
          # prefer a PAT in GH_PAT if provided, otherwise fall back to the built-in token
          github-token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          script: |
            // `core` and `github` are injected by actions/github-script
            const OWNER_LOGIN = '${{ inputs.owner_login }}';
            const PROJECT_TITLE = '${{ inputs.project_title }}';
            const graphql = github.graphql;

            function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

            async function retry(fn, attempts = 4, initialDelay = 700) {
              let lastErr;
              for (let i = 0; i < attempts; i++) {
                try { return await fn(); }
                catch (e) {
                  lastErr = e;
                  const delay = initialDelay * Math.pow(2, i);
                  core.info(`Attempt ${i+1} failed: ${e.message || e}. Retrying in ${delay}ms`);
                  await sleep(delay);
                }
              }
              throw lastErr;
            }

            // Resolve owner ID
            const ownerQuery = `
              query($login:String!) {
                repositoryOwner(login:$login) { id login __typename }
              }
            `;
            const ownerRes = await retry(() => graphql(ownerQuery, { login: OWNER_LOGIN }));
            const ownerId = ownerRes && ownerRes.repositoryOwner && ownerRes.repositoryOwner.id;
            if (!ownerId) throw new Error('Unable to resolve owner id for ' + OWNER_LOGIN);
            core.info(`Resolved owner id: ${ownerId} (type=${ownerRes.repositoryOwner.__typename})`);

            // List projectsV2 for owner (paging)
            const listProjectsQuery = `
              query($ownerId:ID!,$after:String) {
                node(id:$ownerId) {
                  ... on Organization {
                    projectsV2(first:100, after:$after) { pageInfo { hasNextPage endCursor } nodes { id title number } }
                  }
                  ... on User {
                    projectsV2(first:100, after:$after) { pageInfo { hasNextPage endCursor } nodes { id title number } }
                  }
                }
              }
            `;
            let projects = [];
            let after = null;
            do {
              const res = await retry(() => graphql(listProjectsQuery, { ownerId, after }));
              const node = res.node;
              const p = node && node.projectsV2;
              if (p && p.nodes) projects = projects.concat(p.nodes);
              after = p && p.pageInfo && p.pageInfo.hasNextPage ? p.pageInfo.endCursor : null;
            } while (after);

            let project = projects.find(p => p.title === PROJECT_TITLE);
            if (!project) {
              core.info(`ProjectV2 titled "${PROJECT_TITLE}" not found — creating`);
              const createProjectMutation = `
                mutation($ownerId:ID!,$title:String!){
                  createProjectV2(input:{ownerId:$ownerId,title:$title}){
                    projectV2{ id number title }
                  }
                }
              `;
              const createRes = await retry(() => graphql(createProjectMutation, { ownerId, title: PROJECT_TITLE }));
              project = createRes.createProjectV2.projectV2;
              core.info(`Created ProjectV2 #${project.number}: ${project.title}`);
            } else {
              core.info(`Found existing ProjectV2 #${project.number}: ${project.title}`);
            }

            // Collect existing fields for the project (with paging)
            // IMPORTANT: options are exposed on concrete field node types, so use inline fragments at the nodes level.
            const fieldsQuery = `
              query($projectId:ID!,$after:String) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    fields(first:100, after:$after) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        __typename
                        id
                        name
                        dataType
                        ... on ProjectV2SingleSelectField { options { id name } }
                        ... on ProjectV2MultiSelectField  { options { id name } }
                        # For other concrete field types you can add fragments here as needed
                      }
                    }
                  }
                }
              }
            `;
            let fields = [];
            after = null;
            do {
              const res = await retry(() => graphql(fieldsQuery, { projectId: project.id, after }));
              const p = res.node && res.node.fields;
              if (p && p.nodes) fields = fields.concat(p.nodes);
              after = p && p.pageInfo && p.pageInfo.hasNextPage ? p.pageInfo.endCursor : null;
            } while (after);
            core.info(`Project has ${fields.length} existing fields`);

            // Sanitize and log the shape we received
            try {
              const sanitized = fields.map(f => ({
                id: f.id,
                name: f.name,
                dataType: f.dataType,
                nodeType: f.__typename,
                options: (f.options) ? f.options.map(o => ({ id: o.id, name: o.name })) : undefined
              }));
              core.info(`Existing fields (sanitized): ${JSON.stringify(sanitized, null, 2)}`);
            } catch (e) {
              core.info(`Failed to stringify fields for logging: ${e.message || e}`);
            }

            // Desired canonical fields
            const DESIRED_FIELDS = [
              { name: "Status", dataType: "SINGLE_SELECT", options: ["Planned","In Progress","In Review","Approved","Published","Blocked","Archived"] },
              { name: "Priority", dataType: "SINGLE_SELECT", options: ["High","Medium","Low"] },
              { name: "Risk Level", dataType: "SINGLE_SELECT", options: ["High","Medium","Low"] },
              { name: "Document Type", dataType: "SINGLE_SELECT", options: ["overview","index","policy","guide","checklist"] },
              { name: "Document Subtype", dataType: "SINGLE_SELECT", options: ["core","waas","catalog","policy","guide"] },
              { name: "Document Path", dataType: "TEXT" },
              { name: "Owner Role", dataType: "SINGLE_SELECT", options: ["Documentation Owner","Governance Owner","Security Owner","Operations Owner","Release Owner"] },
              { name: "Approval Required", dataType: "SINGLE_SELECT", options: ["Yes","No"] },
              { name: "Evidence Required", dataType: "SINGLE_SELECT", options: ["Yes","No"] },
              { name: "Review Cycle", dataType: "SINGLE_SELECT", options: ["Annual","Semiannual","Quarterly","Ad hoc"] },
              { name: "Compliance Tags", dataType: "MULTI_SELECT", options: ["Governance","Audit","Security","Compliance","Operations","Release","Engineering"] },
              { name: "Retention", dataType: "SINGLE_SELECT", options: ["Indefinite","7 Years","5 Years","3 Years"] },
              { name: "Evidence Artifacts", dataType: "MULTI_SELECT", options: ["Pull Request","Review Approval","Published Document","Audit Record"] },
              { name: "Dependencies", dataType: "TEXT" },
              { name: "Acceptance Criteria", dataType: "TEXT" },
              { name: "RACI", dataType: "TEXT" },
              { name: "KPI – Timeliness", dataType: "TEXT" },
              { name: "KPI – Quality", dataType: "TEXT" },
              { name: "KPI – Compliance", dataType: "TEXT" }
            ];

            // Mutation to create a field (options are optional)
            // Return the created field with concrete-type fragments (options on the concrete nodes)
            const createFieldMutation = `
              mutation(
                $projectId: ID!,
                $name: String!,
                $dataType: ProjectV2CustomFieldType!,
                $singleSelectOptions: [ProjectV2SingleSelectFieldOptionInput!],
                $multiSelectOptions: [ProjectV2MultiSelectFieldOptionInput!]
              ) {
                createProjectV2Field(input:{
                  projectId: $projectId,
                  name: $name,
                  dataType: $dataType,
                  singleSelectOptions: $singleSelectOptions,
                  multiSelectOptions: $multiSelectOptions
                }){
                  projectV2Field {
                    __typename
                    id
                    name
                    ... on ProjectV2SingleSelectField { options { id name } }
                    ... on ProjectV2MultiSelectField  { options { id name } }
                  }
                }
              }
            `;

            let createdCount = 0;
            for (const f of DESIRED_FIELDS) {
              // find exact match by name + dataType
              const exists = fields.find(e => e.name === f.name && e.dataType === f.dataType);
              // find by name only (different data type)
              const existsByName = fields.find(e => e.name === f.name && e.dataType !== f.dataType);

              if (exists) {
                core.info(`Field already exists: ${f.name} (${f.dataType}) — skipping creation`);
                continue;
              }

              if (existsByName) {
                core.info(`A field with name "${f.name}" already exists with dataType=${existsByName.dataType}. Skipping to avoid conflict.`);
                continue;
              }

              core.info(`Creating field: ${f.name} (${f.dataType})`);
              const vars = {
                projectId: project.id,
                name: f.name,
                dataType: f.dataType,
                singleSelectOptions: (f.dataType === 'SINGLE_SELECT' && f.options) ? f.options.map(o => ({ name: o })) : null,
                multiSelectOptions: (f.dataType === 'MULTI_SELECT' && f.options) ? f.options.map(o => ({ name: o })) : null,
              };

              try {
                const createRes = await retry(() => graphql(createFieldMutation, vars));
                const created = createRes && createRes.createProjectV2Field && createRes.createProjectV2Field.projectV2Field;
                core.info(`Create result (sanitized): ${JSON.stringify({
                  id: created && created.id,
                  name: created && created.name,
                  nodeType: created && created.__typename,
                  options: created && created.options ? created.options.map(o => ({ id: o.id, name: o.name })) : undefined
                })}`);
                createdCount++;
                core.info(`Created field ${f.name}`);
              } catch (e) {
                // Normalize message(s) from GraphQL response to detect duplicate/existing-field errors
                let apiMessages = '';
                try {
                  if (e && e.response && Array.isArray(e.response.errors)) {
                    apiMessages = e.response.errors.map(err => err && err.message ? String(err.message) : '').join(' ; ');
                  }
                } catch (inner) {
                  // ignore
                }
                const topMessage = (e && e.message) ? String(e.message) : '';
                const combined = `${topMessage} ${apiMessages}`.trim();

                // If the error looks like a duplicate/existing-field error, treat it as non-fatal
                if (/already|exists|duplicate|duplicate key/i.test(combined)) {
                  core.info(`Create returned duplicate/existing error for "${f.name}": ${combined}. Treating as success and continuing.`);
                  continue;
                }

                core.info(`Failed to create field ${f.name}: ${combined}`);
              }
            }

            core.info(`Done — created ${createdCount} fields (skipped existing).`)
