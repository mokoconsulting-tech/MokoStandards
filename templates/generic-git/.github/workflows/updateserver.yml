name: Update Joomla Update Server XML

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to publish (defaults to release tag on release events)"
        required: false
        default: ""
      asset_name:
        description: "ZIP asset base name (without .zip). Defaults to <repo>-<version>."
        required: false
        default: ""

permissions:
  contents: write

env:
  EXT_NAME: "MokoWaaSBrand"
  EXT_ELEMENT: "mokowaasbrand"
  EXT_TYPE: "plugin"
  EXT_FOLDER: "system"
  EXT_CLIENT: "site"
  EXT_INFOURL: "https://github.com/mokoconsulting-tech/mokowaasbrand"
  EXT_CATEGORY: "MokoWaaSBrand"

jobs:
  update-server:
    name: Publish version to UpdateServer
    runs-on: ubuntu-latest
    environment: UpdateServer

    steps:
      - name: Resolve version and asset metadata
        id: meta
        run: |
          # Determine version
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi

          if [ -z "$VERSION" ]; then
            echo "Version is not defined. Provide it via workflow_dispatch input 'version' when not running on a release."
            exit 1
          fi

          # Determine asset base name
          if [ -n "${{ github.event.inputs.asset_name }}" ]; then
            ASSET_NAME="${{ github.event.inputs.asset_name }}"
          else
            REPO_NAME="${GITHUB_REPOSITORY##*/}"
            ASSET_NAME="${REPO_NAME}-${VERSION}"
          fi

          DOWNLOAD_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${VERSION}/${ASSET_NAME}.zip"

          echo "Resolved version: $VERSION"
          echo "Resolved asset name: $ASSET_NAME"
          echo "Resolved download URL: $DOWNLOAD_URL"

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "asset_name=$ASSET_NAME" >> "$GITHUB_OUTPUT"
          echo "download_url=$DOWNLOAD_URL" >> "$GITHUB_OUTPUT"

      - name: Parse UpdateServer URL from environment variable
        id: parse
        env:
          UPDATESERVER_FILE_URL: ${{ vars.UPDATESERVER_FILE_URL }}
        run: |
          python << 'PY'
          import os
          from urllib.parse import urlparse

          url = os.environ.get("UPDATESERVER_FILE_URL", "").strip()
          if not url:
              raise SystemExit("UPDATESERVER_FILE_URL is not set in the UpdateServer environment")

          parsed = urlparse(url)
          # Expect something like: /mokoconsulting-tech/MokoUpdates/blob/main/joomla/mokowaasbrand/updates.xml
          path_parts = parsed.path.strip("/").split("/")
          if len(path_parts) < 5 or path_parts[2] != "blob":
              raise SystemExit(f"Unexpected UPDATESERVER_FILE_URL format: {url}")

          owner = path_parts[0]
          repo = path_parts[1]
          branch = path_parts[3]
          file_path = "/".join(path_parts[4:])

          repo_full = f"{owner}/{repo}"

          print(f"Parsed update server repo: {repo_full}")
          print(f"Parsed branch: {branch}")
          print(f"Parsed file path: {file_path}")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"update_repo={repo_full}\n")
              fh.write(f"update_branch={branch}\n")
              fh.write(f"update_file={file_path}\n")
          PY

      - name: Check out update server repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse.outputs.update_repo }}
          ref: ${{ steps.parse.outputs.update_branch }}
          token: ${{ secrets.MOKO_UPDATES_TOKEN }}
          fetch-depth: 0

      - name: Update updates.xml
        env:
          VERSION: ${{ steps.meta.outputs.version }}
          DOWNLOAD_URL: ${{ steps.meta.outputs.download_url }}
          UPDATE_FILE: ${{ steps.parse.outputs.update_file }}
          EXT_NAME: ${{ env.EXT_NAME }}
          EXT_ELEMENT: ${{ env.EXT_ELEMENT }}
          EXT_TYPE: ${{ env.EXT_TYPE }}
          EXT_FOLDER: ${{ env.EXT_FOLDER }}
          EXT_CLIENT: ${{ env.EXT_CLIENT }}
          EXT_INFOURL: ${{ env.EXT_INFOURL }}
          EXT_CATEGORY: ${{ env.EXT_CATEGORY }}
        run: |
          python << 'PY'
          import os
          from datetime import datetime
          import xml.etree.ElementTree as ET
          from pathlib import Path

          xml_path = Path(os.environ["UPDATE_FILE"])

          if not xml_path.exists():
              raise SystemExit(f"{xml_path} not found in update server repository")

          tree = ET.parse(xml_path)
          root = tree.getroot()

          version = os.environ["VERSION"]
          download_url = os.environ["DOWNLOAD_URL"]

          name = os.environ["EXT_NAME"]
          element = os.environ["EXT_ELEMENT"]
          ext_type = os.environ["EXT_TYPE"]
          folder = os.environ["EXT_FOLDER"]
          client = os.environ["EXT_CLIENT"]
          infourl = os.environ["EXT_INFOURL"]
          category = os.environ["EXT_CATEGORY"]

          # Locate existing <update> entry for this version or create a new one
          target_update = None
          for update in root.findall("update"):
              v_node = update.find("version")
              if v_node is not None and v_node.text == version:
                  target_update = update
                  break

          if target_update is None:
              target_update = ET.SubElement(root, "update")
              print(f"Creating new update entry for version {version}")
          else:
              print(f"Updating existing update entry for version {version}")

          def ensure_child(parent, tag, text=None):
              node = parent.find(tag)
              if node is None:
                  node = ET.SubElement(parent, tag)
              if text is not None:
                  node.text = text
              return node

          ensure_child(target_update, "name", name)
          ensure_child(target_update, "description", f"{name} extension")
          ensure_child(target_update, "element", element)
          ensure_child(target_update, "type", ext_type)
          ensure_child(target_update, "folder", folder)
          ensure_child(target_update, "client", client)
          ensure_child(target_update, "version", version)
          ensure_child(target_update, "infourl", infourl)

          downloads = target_update.find("downloads")
          if downloads is None:
              downloads = ET.SubElement(target_update, "downloads")

          # Clear existing downloadurl entries
          for child in list(downloads):
              if child.tag == "downloadurl":
                  downloads.remove(child)

          dl = ET.SubElement(downloads, "downloadurl", type="full", format="zip")
          dl.text = download_url

          ensure_child(target_update, "maintainer", "Moko Consulting")
          ensure_child(target_update, "maintainerurl", "https://mokoconsulting.tech")
          ensure_child(target_update, "category", category)
          ensure_child(target_update, "creationDate", datetime.utcnow().strftime("%Y-%m-%d"))

          tree.write(xml_path, encoding="utf-8", xml_declaration=True)
          PY

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push update server changes
        env:
          VERSION: ${{ steps.meta.outputs.version }}
          UPDATE_FILE: ${{ steps.parse.outputs.update_file }}
        run: |
          git status
          if git diff --quiet; then
            echo "No changes to commit in update server repository."
            exit 0
          fi

          git add "$UPDATE_FILE"
          git commit -m "Update server metadata for version ${VERSION}"
          git push
