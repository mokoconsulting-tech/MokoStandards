# Copyright (C) 2026 Moko Consulting <hello@mokoconsulting.tech>
# SPDX-License-Identifier: GPL-3.0-or-later
# FILE INFORMATION
# DEFGROUP: GitHub.Workflow
# INGROUP: MokoStandards.Reusable
# REPO: https://github.com/mokoconsulting-tech/MokoStandards
# PATH: /.github/workflows/reusable-release.yml
# VERSION: 01.00.00
# BRIEF: Reusable type-aware release workflow for Joomla, Dolibarr, and generic projects
# NOTE: Creates releases with type-specific packaging and optional marketplace publishing

name: Reusable Release

on:
  workflow_call:
    inputs:
      version:
        description: 'Release version (semver format)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false
      draft:
        description: 'Create as draft release'
        required: false
        type: boolean
        default: false
      php-version:
        description: 'PHP version for build'
        required: false
        type: string
        default: '8.1'
      create-github-release:
        description: 'Create GitHub release'
        required: false
        type: boolean
        default: true
      publish-to-marketplace:
        description: 'Publish to marketplace (Joomla/Dolibarr)'
        required: false
        type: boolean
        default: false
      working-directory:
        description: 'Working directory'
        required: false
        type: string
        default: '.'
    secrets:
      MARKETPLACE_TOKEN:
        description: 'Marketplace API token (JED/Dolistore)'
        required: false

permissions:
  contents: write

jobs:
  detect:
    name: Detect Project Type
    uses: ./.github/workflows/reusable-project-detector.yml
    with:
      working-directory: ${{ inputs.working-directory }}

  build-package:
    name: Build Release Package
    runs-on: ubuntu-latest
    needs: detect
    outputs:
      package-name: ${{ steps.package.outputs.name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup PHP
        if: needs.detect.outputs.has-php == 'true'
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ inputs.php-version }}
          extensions: mbstring, xml, zip
          tools: composer:v2

      - name: Setup Node.js
        if: needs.detect.outputs.has-node == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: '20.x'

      - name: Validate version format
        run: |
          VERSION="${{ inputs.version }}"
          if ! echo "$VERSION" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$'; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected semver format: X.Y.Z or X.Y.Z-prerelease"
            exit 1
          fi
          echo "âœ… Version format valid: $VERSION"

      - name: Install dependencies
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ -f "composer.json" ]; then
            composer install --no-dev --optimize-autoloader --no-interaction
            echo "âœ… Composer dependencies installed" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f "package.json" ]; then
            npm ci
            if grep -q '"build"' package.json; then
              npm run build
            fi
            echo "âœ… Node dependencies installed and built" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Update version in files
        working-directory: ${{ inputs.working-directory }}
        run: |
          VERSION="${{ inputs.version }}"

          # Update version in XML manifests (Joomla/Dolibarr)
          if [ "${{ needs.detect.outputs.project-type }}" == "joomla" ] || \
             [ "${{ needs.detect.outputs.project-type }}" == "dolibarr" ]; then
            find . -name "*.xml" -type f -not -path "*/node_modules/*" -not -path "*/vendor/*" \
              -exec sed -i "s/<version>[^<]*<\/version>/<version>${VERSION}<\/version>/g" {} \;
            echo "- âœ… Updated version in XML manifests" >> $GITHUB_STEP_SUMMARY
          fi

          # Update version in package.json
          if [ -f "package.json" ]; then
            sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"${VERSION}\"/g" package.json
            echo "- âœ… Updated version in package.json" >> $GITHUB_STEP_SUMMARY
          fi

          # Update version in composer.json
          if [ -f "composer.json" ]; then
            sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"${VERSION}\"/g" composer.json
            echo "- âœ… Updated version in composer.json" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create Joomla package
        if: needs.detect.outputs.project-type == 'joomla'
        working-directory: ${{ inputs.working-directory }}
        run: |
          VERSION="${{ inputs.version }}"
          
          # Check if src directory exists
          if [ ! -d "src" ]; then
            echo "âŒ ERROR: src directory not found. Joomla extensions must be in src/ directory" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          # Use package_extension.py script with src directory
          python3 scripts/release/package_extension.py \
            --src-dir src \
            build \
            "${VERSION}"
          
          # Find the created package
          PACKAGE=$(find build -name "*.zip" -type f | head -1)
          if [ -z "$PACKAGE" ]; then
            echo "âŒ ERROR: No package created" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          PACKAGE_NAME=$(basename "$PACKAGE")
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          echo "âœ… Created Joomla package from src directory: ${PACKAGE_NAME}" >> $GITHUB_STEP_SUMMARY

      - name: Create Dolibarr package
        if: needs.detect.outputs.project-type == 'dolibarr'
        working-directory: ${{ inputs.working-directory }}
        run: |
          VERSION="${{ inputs.version }}"
          
          # Check if src directory exists - REQUIRED for all ZIP builds
          if [ ! -d "src" ]; then
            echo "âŒ ERROR: src directory not found. Dolibarr modules must be in src/ directory" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          # Use package_extension.py script for platform-aware packaging
          python3 scripts/release/package_extension.py \
            --src-dir src \
            build \
            "${VERSION}"
          
          # Find the created package
          PACKAGE=$(find build -name "*.zip" -type f | head -1)
          if [ -z "$PACKAGE" ]; then
            echo "âŒ ERROR: No package created" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          PACKAGE_NAME=$(basename "$PACKAGE")
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          echo "âœ… Created Dolibarr package from src directory with platform identifier: ${PACKAGE_NAME}" >> $GITHUB_STEP_SUMMARY

      - name: Create Generic package
        if: needs.detect.outputs.project-type == 'generic'
        working-directory: ${{ inputs.working-directory }}
        run: |
          mkdir -p build/package

          # Copy relevant build artifacts
          if [ -d "dist" ]; then
            cp -r dist/* build/package/
          elif [ -d "build" ]; then
            cp -r build/* build/package/
          else
            # Copy all files excluding development artifacts
            rsync -av \
              --exclude='build' \
              --exclude='tests' \
              --exclude='.git*' \
              --exclude='node_modules' \
              . build/package/
          fi

          # Create package with platform identifier
          REPO_NAME=$(basename "$GITHUB_REPOSITORY")
          VERSION="${{ inputs.version }}"
          PACKAGE_NAME="${REPO_NAME}-${VERSION}-generic.tar.gz"

          cd build
          tar -czf "${PACKAGE_NAME}" package/
          cd ..

          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          echo "âœ… Created generic package with platform identifier: ${PACKAGE_NAME}" >> $GITHUB_STEP_SUMMARY

      - name: Generate checksums
        working-directory: ${{ inputs.working-directory }}
        run: |
          cd build
          PACKAGE="${PACKAGE_NAME}"

          if [ -f "$PACKAGE" ]; then
            sha256sum "$PACKAGE" > "${PACKAGE}.sha256"
            md5sum "$PACKAGE" > "${PACKAGE}.md5"
            echo "âœ… Generated checksums" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Output package info
        id: package
        run: |
          echo "name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Upload release artifacts
        uses: actions/upload-artifact@v6
        with:
          name: release-package
          path: |
            ${{ inputs.working-directory }}/build/*.zip
            ${{ inputs.working-directory }}/build/*.tar.gz
            ${{ inputs.working-directory }}/build/*.sha256
            ${{ inputs.working-directory }}/build/*.md5
          retention-days: 30

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [detect, build-package]
    if: inputs.create-github-release

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for existing prerelease
        id: check-prerelease
        run: |
          VERSION="${{ inputs.version }}"
          
          # Check if a prerelease already exists for this version
          EXISTING_RELEASE=$(gh release view "v${VERSION}" --json isPrerelease,isDraft 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_RELEASE" ]; then
            IS_PRERELEASE=$(echo "$EXISTING_RELEASE" | jq -r '.isPrerelease')
            IS_DRAFT=$(echo "$EXISTING_RELEASE" | jq -r '.isDraft')
            
            if [ "$IS_PRERELEASE" == "true" ] && [ "$IS_DRAFT" == "false" ]; then
              echo "prerelease_exists=true" >> $GITHUB_OUTPUT
              echo "âš ï¸ Prerelease already exists for v${VERSION}" >> $GITHUB_STEP_SUMMARY
              echo "Will promote to stable release" >> $GITHUB_STEP_SUMMARY
            else
              echo "prerelease_exists=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "prerelease_exists=false" >> $GITHUB_OUTPUT
            echo "No existing release found for v${VERSION}" >> $GITHUB_STEP_SUMMARY
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine release type
        id: release-type
        run: |
          # If prerelease exists, promote to stable
          if [ "${{ steps.check-prerelease.outputs.prerelease_exists }}" == "true" ]; then
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "release_notes_prefix=## Stable Release\n\nPromoted from prerelease.\n\n" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Promoting prerelease to stable release" >> $GITHUB_STEP_SUMMARY
          else
            # Otherwise create as prerelease by default
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "release_notes_prefix=## Prerelease\n\nThis is a release candidate (RC) for testing.\n\n" >> $GITHUB_OUTPUT
            echo "ðŸš§ Creating prerelease (RC)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Download release artifacts
        uses: actions/download-artifact@v7
        with:
          name: release-package
          path: ./artifacts

      - name: Add release type suffix to artifacts
        run: |
          cd artifacts
          IS_PRERELEASE="${{ steps.release-type.outputs.is_prerelease }}"
          
          for file in *; do
            if [[ "$file" == *.zip ]] || [[ "$file" == *.tar.gz ]]; then
              # Extract name and extension
              basename="${file%.*}"
              extension="${file##*.}"
              if [[ "$file" == *.tar.gz ]]; then
                basename="${file%.tar.gz}"
                extension="tar.gz"
              fi
              
              # Add appropriate suffix based on release type
              if [ "$IS_PRERELEASE" == "true" ]; then
                # Add RC suffix if not already present
                if [[ ! "$basename" =~ -rc ]]; then
                  newname="${basename}-rc.${extension}"
                  suffix_type="RC"
                fi
              else
                # Add stable suffix if not already present
                if [[ ! "$basename" =~ -stable ]]; then
                  newname="${basename}-stable.${extension}"
                  suffix_type="stable"
                fi
              fi
              
              # Rename if a new name was determined
              if [ -n "$newname" ]; then
                mv "$file" "$newname"
                echo "âœ… Renamed $file to $newname ($suffix_type)" >> $GITHUB_STEP_SUMMARY
                
                # Update corresponding checksum files
                if [ -f "${file}.sha256" ]; then
                  mv "${file}.sha256" "${newname}.sha256"
                  sed -i "s/${file}/${newname}/g" "${newname}.sha256"
                fi
                if [ -f "${file}.md5" ]; then
                  mv "${file}.md5" "${newname}.md5"
                  sed -i "s/${file}/${newname}/g" "${newname}.md5"
                fi
                
                # Reset newname for next iteration
                unset newname
              fi
            fi
          done

      - name: Extract changelog
        id: changelog
        run: |
          VERSION="${{ inputs.version }}"
          RELEASE_PREFIX="${{ steps.release-type.outputs.release_notes_prefix }}"

          if [ -f "CHANGELOG.md" ]; then
            # Extract changelog for this version
            awk "/## \[${VERSION}\]/,/## \[/{if(/## \[${VERSION}\]/)next;else if(/## \[/)exit;else print}" CHANGELOG.md > release_notes.md

            if [ ! -s release_notes.md ]; then
              echo -e "${RELEASE_PREFIX}" > release_notes.md
              echo "## Release ${VERSION}" >> release_notes.md
              echo "" >> release_notes.md
              echo "No specific changelog found for this version." >> release_notes.md
              echo "Please refer to the full CHANGELOG.md for details." >> release_notes.md
            else
              # Prepend release type info
              echo -e "${RELEASE_PREFIX}" | cat - release_notes.md > temp && mv temp release_notes.md
            fi
          else
            echo -e "${RELEASE_PREFIX}" > release_notes.md
            echo "## Release ${VERSION}" >> release_notes.md
            echo "" >> release_notes.md
            echo "Release created from ${{ needs.detect.outputs.project-type }} project." >> release_notes.md
          fi

      - name: Delete existing prerelease if promoting
        if: steps.check-prerelease.outputs.prerelease_exists == 'true'
        run: |
          VERSION="${{ inputs.version }}"
          echo "Deleting existing prerelease v${VERSION}..."
          gh release delete "v${VERSION}" --yes --cleanup-tag || true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.version }}
          name: Release ${{ inputs.version }}
          body_path: release_notes.md
          draft: ${{ inputs.draft }}
          prerelease: ${{ steps.release-type.outputs.is_prerelease }}
          files: |
            artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "### ðŸš€ Release Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Project Type:** ${{ needs.detect.outputs.project-type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Extension Type:** ${{ needs.detect.outputs.extension-type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Pre-release:** ${{ steps.release-type.outputs.is_prerelease }}" >> $GITHUB_STEP_SUMMARY
          echo "**Draft:** ${{ inputs.draft }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Package:** ${{ needs.build-package.outputs.package-name }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.release-type.outputs.is_prerelease }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ **This is a Release Candidate (RC) for testing**" >> $GITHUB_STEP_SUMMARY
            echo "Run this workflow again with the same version to promote to stable release." >> $GITHUB_STEP_SUMMARY
          fi

  publish-marketplace:
    name: Publish to Marketplace
    runs-on: ubuntu-latest
    needs: [detect, build-package, create-release]
    if: inputs.publish-to-marketplace && (needs.detect.outputs.project-type == 'joomla' || needs.detect.outputs.project-type == 'dolibarr')

    steps:
      - name: Download release artifacts
        uses: actions/download-artifact@v7
        with:
          name: release-package
          path: ./artifacts

      - name: Publish to marketplace
        run: |
          echo "### ðŸŒ Marketplace Publishing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PROJECT_TYPE="${{ needs.detect.outputs.project-type }}"

          if [ "$PROJECT_TYPE" == "joomla" ]; then
            echo "âš ï¸ Joomla Extensions Directory (JED) publishing requires manual submission" >> $GITHUB_STEP_SUMMARY
            echo "Package ready at: artifacts/${{ needs.build-package.outputs.package-name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To publish to JED:" >> $GITHUB_STEP_SUMMARY
            echo "1. Visit https://extensions.joomla.org/" >> $GITHUB_STEP_SUMMARY
            echo "2. Login and submit the extension package" >> $GITHUB_STEP_SUMMARY
          elif [ "$PROJECT_TYPE" == "dolibarr" ]; then
            echo "âš ï¸ Dolistore publishing requires manual submission" >> $GITHUB_STEP_SUMMARY
            echo "Package ready at: artifacts/${{ needs.build-package.outputs.package-name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To publish to Dolistore:" >> $GITHUB_STEP_SUMMARY
            echo "1. Visit https://www.dolistore.com/" >> $GITHUB_STEP_SUMMARY
            echo "2. Login and submit the module package" >> $GITHUB_STEP_SUMMARY
          fi

          # Note: Automated marketplace publishing would require
          # marketplace-specific API implementation here
          # For now, we provide manual instructions
