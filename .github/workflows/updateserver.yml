name: Update Joomla Update Server XML Feed

on:
  release:
    types: [prereleased, released]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to publish (defaults to release tag on release events)"
        required: false
        default: ""
      asset_name:
        description: "ZIP asset base name (without .zip). Defaults to <repo>-<version>."
        required: false
        default: ""

permissions:
  contents: write
  issues: write

env:
  EXT_NAME: "MokoWaaS-Brand"
  EXT_ELEMENT: "mokowaasbrand"
  EXT_TYPE: "plugin"
  EXT_FOLDER: "system"
  EXT_CLIENT: "site"
  EXT_INFOURL: "https://github.com/mokoconsulting-tech/mokowaasbrand"
  EXT_CATEGORY: "MokoWaaS-Brand"

jobs:
  update-server:
    name: Publish version to UpdateServer
    runs-on: ubuntu-latest
    environment: UpdateServer

    steps:
      - name: Resolve version and asset metadata
        id: meta
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi

          if [ -z "$VERSION" ]; then
            echo "Version is not defined. Provide it via workflow_dispatch input 'version' when not running on a release."
            exit 1
          fi

          # Skip RC versions (do not publish to update server)
          if echo "$VERSION" | grep -qiE "(^|[-.])rc([-.]|$)"; then
            echo "RC version detected (${VERSION}). Update server publication is skipped by policy."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.asset_name }}" ]; then
            ASSET_NAME="${{ github.event.inputs.asset_name }}"
          else
            REPO_NAME="${GITHUB_REPOSITORY##*/}"
            ASSET_NAME="${REPO_NAME}-${VERSION}"
          fi

          DOWNLOAD_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${VERSION}/${ASSET_NAME}.zip"

          echo "Resolved version: $VERSION"
          echo "Resolved asset name: $ASSET_NAME"
          echo "Resolved download URL: $DOWNLOAD_URL"

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "asset_name=$ASSET_NAME" >> "$GITHUB_OUTPUT"
          echo "download_url=$DOWNLOAD_URL" >> "$GITHUB_OUTPUT"

      - name: Parse UpdateServer URL from environment variable
        if: steps.meta.outputs.skip != 'true'
        id: parse
        env:
          UPDATESERVER_FILE_URL: ${{ vars.UPDATESERVER_FILE_URL }}
        run: |
          python << 'PY'
          import os
          from urllib.parse import urlparse

          url = os.environ.get("UPDATESERVER_FILE_URL", "").strip()
          if not url:
              raise SystemExit("UPDATESERVER_FILE_URL is not set in the UpdateServer environment")

          parsed = urlparse(url)
          parts = parsed.path.strip("/").split("/")

          # Expect: <owner>/<repo>/blob/<branch>/<path...>
          if len(parts) < 5 or parts[2] != "blob":
              raise SystemExit(f"Unexpected UPDATESERVER_FILE_URL format: {url}")

          owner = parts[0]
          repo = parts[1]
          branch = parts[3]
          file_path = "/".join(parts[4:])

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"update_repo={owner}/{repo}")
              fh.write(f"update_branch={branch}")
              fh.write(f"update_file={file_path}")
          PY

      - name: Check out update server repository
        if: steps.meta.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse.outputs.update_repo }}
          ref: ${{ steps.parse.outputs.update_branch }}
          token: ${{ secrets.MOKO_UPDATES_TOKEN }}
          fetch-depth: 0

      - name: Update updates.xml
        if: steps.meta.outputs.skip != 'true'
        env:
          VERSION: ${{ steps.meta.outputs.version }}
          DOWNLOAD_URL: ${{ steps.meta.outputs.download_url }}
          UPDATE_FILE: ${{ steps.parse.outputs.update_file }}
          EXT_NAME: ${{ env.EXT_NAME }}
          EXT_ELEMENT: ${{ env.EXT_ELEMENT }}
          EXT_TYPE: ${{ env.EXT_TYPE }}
          EXT_FOLDER: ${{ env.EXT_FOLDER }}
          EXT_CLIENT: ${{ env.EXT_CLIENT }}
          EXT_INFOURL: ${{ env.EXT_INFOURL }}
          EXT_CATEGORY: ${{ env.EXT_CATEGORY }}
        run: |
          python << 'PY'
          import os
          from datetime import datetime
          import xml.etree.ElementTree as ET
          from pathlib import Path

          xml_path = Path(os.environ["UPDATE_FILE"])
          if not xml_path.exists():
              raise SystemExit(f"{xml_path} not found in update server repository")

          tree = ET.parse(xml_path)
          root = tree.getroot()

          version = os.environ["VERSION"]
          download_url = os.environ["DOWNLOAD_URL"]

          name = os.environ["EXT_NAME"]
          element = os.environ["EXT_ELEMENT"]
          ext_type = os.environ["EXT_TYPE"]
          folder = os.environ["EXT_FOLDER"]
          client = os.environ["EXT_CLIENT"]
          infourl = os.environ["EXT_INFOURL"]
          category = os.environ["EXT_CATEGORY"]

          target = None
          for upd in root.findall("update"):
              v_node = upd.find("version")
              if v_node is not None and (v_node.text or "").strip() == version:
                  target = upd
                  break

          if target is None:
              target = ET.SubElement(root, "update")

          def ensure_child(parent, tag, text=None):
              node = parent.find(tag)
              if node is None:
                  node = ET.SubElement(parent, tag)
              if text is not None:
                  node.text = text
              return node

          ensure_child(target, "name", name)
          ensure_child(target, "description", f"{name} extension")
          ensure_child(target, "element", element)
          ensure_child(target, "type", ext_type)
          ensure_child(target, "folder", folder)
          ensure_child(target, "client", client)
          ensure_child(target, "version", version)
          ensure_child(target, "infourl", infourl)

          downloads = target.find("downloads")
          if downloads is None:
              downloads = ET.SubElement(target, "downloads")

          for child in list(downloads):
              if child.tag == "downloadurl":
                  downloads.remove(child)

          dl = ET.SubElement(downloads, "downloadurl", type="full", format="zip")
          dl.text = download_url

          ensure_child(target, "maintainer", "Moko Consulting")
          ensure_child(target, "maintainerurl", "https://mokoconsulting.tech")
          ensure_child(target, "category", category)
          ensure_child(target, "creationDate", datetime.utcnow().strftime("%Y-%m-%d"))

          tree.write(xml_path, encoding="utf-8", xml_declaration=True)
          PY

      - name: Configure git user
        if: steps.meta.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push update server changes
        if: steps.meta.outputs.skip != 'true'
        env:
          VERSION: ${{ steps.meta.outputs.version }}
          UPDATE_FILE: ${{ steps.parse.outputs.update_file }}
        run: |
          git status

          if git diff --quiet; then
            echo "No changes to commit in update server repository."
            exit 0
          fi

          git add "${UPDATE_FILE}" README.md || true
          git commit -m "Update server metadata for version ${VERSION}"
          git push
