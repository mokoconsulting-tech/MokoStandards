# Copyright (C) 2026 Moko Consulting <hello@mokoconsulting.tech>
# SPDX-License-Identifier: GPL-3.0-or-later
# FILE INFORMATION
# DEFGROUP: GitHub.Workflow
# INGROUP: MokoStandards.Security
# REPO: https://github.com/mokoconsulting-tech/MokoStandards
# PATH: /.github/workflows/confidentiality-scan.yml
# VERSION: 03.01.01
# BRIEF: Scan for confidential data leakage in public repository
# NOTE: Prevents organization-specific references and sensitive data from being committed

name: Confidentiality Scan

env:
  ACTIONS_STEP_DEBUG: true
  ACTIONS_RUNNER_DEBUG: true

# MokoStandards Policy Compliance:
# - File formatting: Enforces organizational coding standards
# - Reference: docs/policy/file-formatting.md

# ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
# ‚îÇ                         WORKFLOW FLOW DIAGRAM                            ‚îÇ
# ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#
#   TRIGGER: Push/PR to main/dev/rc/version branches
#        ‚îÇ
#        ‚ñº
#   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#   ‚îÇ Checkout Code    ‚îÇ
#   ‚îÇ (Full History)   ‚îÇ
#   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#        ‚îÇ
#        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#        ‚îÇ                                              ‚îÇ
#        ‚ñº                                              ‚ñº
#   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#   ‚îÇ Scan Organization  ‚îÇ                    ‚îÇ  Scan Sensitive    ‚îÇ
#   ‚îÇ    References      ‚îÇ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ     Patterns       ‚îÇ
#   ‚îÇ (private repos,    ‚îÇ   ‚îÇ                ‚îÇ (API keys, tokens, ‚îÇ
#   ‚îÇ  internal URLs)    ‚îÇ   ‚îÇ                ‚îÇ  credentials)      ‚îÇ
#   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#        ‚îÇ                   ‚îÇ                         ‚îÇ
#        ‚ñº                   ‚îÇ                         ‚ñº
#   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#   ‚îÇ Detect Violations  ‚îÇ‚óÄ‚îÄ‚îÄ‚îò                ‚îÇ Detect Secrets     ‚îÇ
#   ‚îÇ   in Files         ‚îÇ                    ‚îÇ   & Leaks          ‚îÇ
#   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#        ‚îÇ                                              ‚îÇ
#        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#                           ‚îÇ
#                           ‚ñº
#                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#                  ‚îÇ Violations      ‚îÇ
#                  ‚îÇ   Found?        ‚îÇ
#                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#                      ‚îÇ          ‚îÇ
#                  YES ‚îÇ          ‚îÇ NO
#                      ‚ñº          ‚ñº
#            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#            ‚îÇCREATE ISSUE ‚îÇ  ‚îÇ SUCCESS ‚îÇ
#            ‚îÇwith Details:‚îÇ  ‚îÇ  Report ‚îÇ
#            ‚îÇ‚Ä¢ File Paths ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#            ‚îÇ‚Ä¢ Violation  ‚îÇ
#            ‚îÇ  Types      ‚îÇ
#            ‚îÇ‚Ä¢ Remediation‚îÇ
#            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

on:
  pull_request:
    branches:
      - main
      - dev/**
      - rc/**
      - version/**
  push:
    branches:
      - main
      - dev/**
      - rc/**
      - version/**
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to scan (default: current branch)'
        required: false
        type: string
        default: ''

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

jobs:
  scan-confidential-data:
    name: Scan for Confidential Data
    runs-on: ubuntu-latest

    env:
      # Excluded files from confidentiality scans
      # Note: Terraform *.tf files ARE scanned for secrets (as they should be)
      # Only Terraform state/plan/cache files are excluded (they may contain computed values)
      EXCLUDED_FILES: ':!.github/workflows/confidentiality-scan.yml :!docs/TWO_TIER_ARCHITECTURE.md :!docs/guide/PRIVATE_REPOSITORY_REFERENCE.md :!STANDARDS_COORDINATION.md :!.github/PRIVATE_TEMPLATES.md :!terraform/*.tfplan :!terraform/*.tfstate* :!terraform/.terraform/*'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Scan for organization-specific references
        id: org_scan
        run: |
          set -x
          echo "Scanning for organization-specific references..."

          # Define forbidden patterns
          FORBIDDEN_PATTERNS=(
            "@mokoconsulting-tech/[a-zA-Z0-9_-]+"
            "\.github-private"
            "CONFIDENTIAL"
            "INTERNAL ONLY"
            "DO NOT SHARE"
            "ftp\.[a-zA-Z0-9_-]+\.mokoconsulting\.tech"
            "mokoconsulting-tech\.slack\.com"
            "private\.mokoconsulting\.tech"
          )

          # Initialize results
          VIOLATIONS_FOUND=0
          VIOLATION_DETAILS=""

          # Scan each pattern
          for pattern in "${FORBIDDEN_PATTERNS[@]}"; do
            echo "Checking pattern: $pattern"

            # Search for pattern (case insensitive)
            # Use -- to separate options from pattern (prevents patterns starting with - from being interpreted as options)
            matches=$(git grep -i -n -I -E -- "$pattern" $EXCLUDED_FILES || true)

            if [ -n "$matches" ]; then
              VIOLATIONS_FOUND=$((VIOLATIONS_FOUND + 1))
              VIOLATION_DETAILS="${VIOLATION_DETAILS}
              ### Pattern: \`${pattern}\`
              \`\`\`
              ${matches}
              \`\`\`
              "
            fi
          done

          # Save results
          echo "violations_found=${VIOLATIONS_FOUND}" >> $GITHUB_OUTPUT

          # Save details to file for later use
          if [ -n "$VIOLATION_DETAILS" ]; then
            echo "$VIOLATION_DETAILS" > /tmp/violation_details.txt
          fi

          if [ $VIOLATIONS_FOUND -gt 0 ]; then
            echo "‚ùå Found ${VIOLATIONS_FOUND} pattern(s) with forbidden content"
            exit 1
          else
            echo "‚úÖ No forbidden patterns found"
            exit 0
          fi

      - name: Scan for potential secrets
        id: secret_scan
        if: success() || failure()
        run: |
          set -x
          echo "Scanning for potential secrets..."

          # Define secret patterns
          SECRET_PATTERNS=(
            "password\s*=\s*['\"][^'\"]+['\"]"
            "api[_-]?key\s*=\s*['\"][^'\"]+['\"]"
            "secret[_-]?key\s*=\s*['\"][^'\"]+['\"]"
            "token\s*=\s*['\"][^'\"]+['\"]"
            "-----BEGIN\s+(RSA|DSA|EC|OPENSSH)\s+PRIVATE\s+KEY-----"
            "AKIA[0-9A-Z]{16}"
            "ghp_[a-zA-Z0-9]{36}"
            "gho_[a-zA-Z0-9]{36}"
            "ghu_[a-zA-Z0-9]{36}"
          )

          SECRETS_FOUND=0
          SECRET_DETAILS=""

          for pattern in "${SECRET_PATTERNS[@]}"; do
            echo "Checking secret pattern: $pattern"

            # Search for pattern (case insensitive, exclude example files)
            # Use -- to separate options from pattern (prevents patterns starting with - from being interpreted as options)
            matches=$(git grep -i -n -I -E -- "$pattern" ':!*.md' ':!*.example' ':!*.sample' ':!docs/*' $EXCLUDED_FILES || true)

            if [ -n "$matches" ]; then
              SECRETS_FOUND=$((SECRETS_FOUND + 1))
              # Mask potential secret values in output
              masked_matches=$(echo "$matches" | sed -E 's/(password|api[_-]?key|secret[_-]?key|token)\s*=\s*['\''"][^'\''"]+['\''"]/\1=***REDACTED***/gi')
              SECRET_DETAILS="${SECRET_DETAILS}
              ### Potential Secret Pattern: \`${pattern}\`
              \`\`\`
              ${masked_matches}
              \`\`\`
              "
            fi
          done

          echo "secrets_found=${SECRETS_FOUND}" >> $GITHUB_OUTPUT

          # Save details
          if [ -n "$SECRET_DETAILS" ]; then
            echo "$SECRET_DETAILS" > /tmp/secret_details.txt
          fi

          if [ $SECRETS_FOUND -gt 0 ]; then
            echo "‚ö†Ô∏è Found ${SECRETS_FOUND} potential secret pattern(s)"
            exit 1
          else
            echo "‚úÖ No potential secrets found"
            exit 0
          fi

      - name: Scan for internal documentation references
        id: doc_scan
        if: success() || failure()
        run: |
          set -x
          echo "Scanning for internal documentation references..."

          # Patterns that suggest internal documentation
          INTERNAL_DOC_PATTERNS=(
            "see internal documentation"
            "refer to internal wiki"
            "contact the team"
            "ask the maintainers"
            "internal process"
            "proprietary"
          )

          INTERNAL_DOCS_FOUND=0
          INTERNAL_DOC_DETAILS=""

          # Only check markdown files
          for pattern in "${INTERNAL_DOC_PATTERNS[@]}"; do
            echo "Checking internal doc pattern: $pattern"

            # Use -- to separate options from pattern (prevents patterns starting with - from being interpreted as options)
            matches=$(git grep -i -n -I -- "$pattern" '*.md' $EXCLUDED_FILES || true)

            if [ -n "$matches" ]; then
              # This is a warning, not a hard failure
              INTERNAL_DOCS_FOUND=$((INTERNAL_DOCS_FOUND + 1))
              INTERNAL_DOC_DETAILS="${INTERNAL_DOC_DETAILS}
              ### Potential Internal Reference: \`${pattern}\`
              \`\`\`
              ${matches}
              \`\`\`
              "
            fi
          done

          echo "internal_docs_found=${INTERNAL_DOCS_FOUND}" >> $GITHUB_OUTPUT

          if [ $INTERNAL_DOCS_FOUND -gt 0 ]; then
            echo "‚ö†Ô∏è Found ${INTERNAL_DOCS_FOUND} potential internal documentation reference(s)"
            if [ -n "$INTERNAL_DOC_DETAILS" ]; then
              echo "$INTERNAL_DOC_DETAILS" > /tmp/internal_doc_details.txt
            fi
          else
            echo "‚úÖ No internal documentation references found"
          fi

      - name: Create check run
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const orgViolations = '${{ steps.org_scan.outcome }}' === 'failure';
            const secretsFound = '${{ steps.secret_scan.outcome }}' === 'failure';
            const internalDocsFound = '${{ steps.doc_scan.outputs.internal_docs_found }}' > 0;

            let conclusion = 'success';
            let summary = '‚úÖ No confidentiality issues detected.';
            let text = 'The confidentiality scan completed successfully with no violations.';

            if (orgViolations || secretsFound) {
              conclusion = 'failure';
              summary = '‚ùå Confidentiality violations detected!';
              text = '## Confidentiality Scan Results\n\n';

              if (orgViolations) {
                text += '### ‚ùå Organization-Specific References Found\n\n';
                text += 'The scan detected organization-specific references that should not be in the public repository.\n\n';

                // Read violation details from file
                try {
                  const violationDetails = fs.readFileSync('/tmp/violation_details.txt', 'utf8');
                  text += violationDetails + '\n\n';
                } catch (err) {
                  text += '_Details could not be loaded._\n\n';
                }

                text += '**Action Required**: Remove or generalize these references before merging.\n\n';
              }

              if (secretsFound) {
                text += '### ‚ùå Potential Secrets Detected\n\n';
                text += 'The scan detected patterns that may indicate secrets or credentials.\n\n';

                // Read secret details from file
                try {
                  const secretDetails = fs.readFileSync('/tmp/secret_details.txt', 'utf8');
                  text += secretDetails + '\n\n';
                } catch (err) {
                  text += '_Details could not be loaded._\n\n';
                }

                text += '**Action Required**: Remove secrets and use environment variables or GitHub Secrets instead.\n\n';
              }

              if (internalDocsFound) {
                text += '### ‚ö†Ô∏è Internal Documentation References Found\n\n';
                text += 'The scan detected potential references to internal documentation.\n\n';

                // Read internal doc details from file
                try {
                  const internalDocDetails = fs.readFileSync('/tmp/internal_doc_details.txt', 'utf8');
                  text += internalDocDetails + '\n\n';
                } catch (err) {
                  text += '_Details could not be loaded._\n\n';
                }

                text += '**Action Recommended**: Review these references and ensure they are appropriate for public documentation.\n\n';
              }

              text += '\n---\n\n';
              text += '## Remediation Steps\n\n';
              text += '1. Review the violations listed above with file names and line numbers\n';
              text += '2. Remove or generalize organization-specific references\n';
              text += '3. Replace hardcoded secrets with GitHub Secrets\n';
              text += '4. Update internal references to public equivalents\n';
              text += '5. Re-run the workflow to verify fixes\n\n';
              text += '## Need Help?\n\n';
              text += '- Review [Two-Tier Architecture](docs/TWO_TIER_ARCHITECTURE.md) for guidance\n';
              text += '- See [Standards Coordination](STANDARDS_COORDINATION.md) for best practices\n';
            } else if (internalDocsFound) {
              conclusion = 'neutral';
              summary = '‚ö†Ô∏è Potential internal references detected (review recommended).';
              text = '## Confidentiality Scan Results\n\n';
              text += '### ‚ö†Ô∏è Internal Documentation References Found\n\n';
              text += 'The scan detected potential references to internal documentation. Review these to ensure they are appropriate for public documentation.\n\n';

              // Read internal doc details
              try {
                const internalDocDetails = fs.readFileSync('/tmp/internal_doc_details.txt', 'utf8');
                text += internalDocDetails + '\n\n';
              } catch (err) {
                text += '_Details could not be loaded._\n\n';
              }
            }

            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Confidentiality Scan',
              head_sha: context.sha,
              conclusion: conclusion,
              output: {
                title: 'Confidentiality Scan Results',
                summary: summary,
                text: text
              }
            });

      - name: Comment on PR
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let body = `## ‚ùå Confidentiality Scan Failed

            This PR contains content that should not be in the public repository.

            ### Issues Detected:
            - ${{ steps.org_scan.outcome == 'failure' && '‚ùå Organization-specific references found' || '‚úÖ No organization references' }}
            - ${{ steps.secret_scan.outcome == 'failure' && '‚ùå Potential secrets detected' || '‚úÖ No secrets detected' }}
            - ${{ steps.doc_scan.outputs.internal_docs_found > 0 && '‚ö†Ô∏è Internal documentation references found' || '‚úÖ No internal doc references' }}
            `;

            // Add violation details if organization scan failed
            if ('${{ steps.org_scan.outcome }}' === 'failure') {
              try {
                const violationDetails = fs.readFileSync('/tmp/violation_details.txt', 'utf8');
                body += '\n### üìç Organization-Specific References (with file:line)\n\n' + violationDetails + '\n';
              } catch (err) {
                body += '\n_Violation details could not be loaded._\n';
              }
            }

            // Add secret details if secret scan failed
            if ('${{ steps.secret_scan.outcome }}' === 'failure') {
              try {
                const secretDetails = fs.readFileSync('/tmp/secret_details.txt', 'utf8');
                body += '\n### üìç Potential Secrets (with file:line)\n\n' + secretDetails + '\n';
              } catch (err) {
                body += '\n_Secret details could not be loaded._\n';
              }
            }

            // Add internal doc details if found
            if ('${{ steps.doc_scan.outputs.internal_docs_found }}' > 0) {
              try {
                const internalDocDetails = fs.readFileSync('/tmp/internal_doc_details.txt', 'utf8');
                body += '\n### üìç Internal Documentation References (with file:line)\n\n' + internalDocDetails + '\n';
              } catch (err) {
                body += '\n_Internal doc details could not be loaded._\n';
              }
            }

            body += `
            ### Action Required:
            1. Review the violations listed above with file names and line numbers
            2. Remove or generalize organization-specific content
            3. Replace any hardcoded secrets with GitHub Secrets
            4. Update internal references to public equivalents

            ### Resources:
            - [Two-Tier Architecture](docs/TWO_TIER_ARCHITECTURE.md)
            - [Standards Coordination](STANDARDS_COORDINATION.md)
            - [Private Repository Reference](docs/guide/PRIVATE_REPOSITORY_REFERENCE.md)

            Once you've addressed the issues, push your changes and the workflow will run again.`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Create tracking issue for violations
        if: |
          (steps.org_scan.outcome == 'failure' || steps.secret_scan.outcome == 'failure' ||
           steps.doc_scan.outcome == 'failure') && github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const orgViolations = '${{ steps.org_scan.outputs.violations_found }}' || '0';
            const secretViolations = '${{ steps.secret_scan.outputs.secrets_found }}' || '0';
            const docViolations = '${{ steps.doc_scan.outputs.internal_docs_found }}' || '0';

            let body = `## üîí Confidentiality Scan Violations Detected

            **Branch**: \`${context.ref}\`
            **Commit**: ${context.sha.substring(0, 7)}
            **Triggered by**: @${context.actor}
            **Date**: ${new Date().toISOString()}

            ### Summary
            - Organization-specific patterns: ${orgViolations}
            - Potential secrets: ${secretViolations}
            - Internal documentation references: ${docViolations}

            `;

            // Add violation details
            if (orgViolations > 0) {
              try {
                const violationDetails = fs.readFileSync('/tmp/violation_details.txt', 'utf8');
                body += '\n### üö® Organization-Specific References\n\n' + violationDetails + '\n';
              } catch (err) {
                body += '\n_Violation details could not be loaded._\n';
              }
            }

            if (secretViolations > 0) {
              try {
                const secretDetails = fs.readFileSync('/tmp/secret_details.txt', 'utf8');
                body += '\n### üîë Potential Secrets Detected\n\n' + secretDetails + '\n';
              } catch (err) {
                body += '\n_Secret details could not be loaded._\n';
              }
            }

            if (docViolations > 0) {
              try {
                const docDetails = fs.readFileSync('/tmp/internal_doc_details.txt', 'utf8');
                body += '\n### üìç Internal Documentation References\n\n' + docDetails + '\n';
              } catch (err) {
                body += '\n_Internal doc details could not be loaded._\n';
              }
            }

            body += `
            ### ‚ö†Ô∏è Action Required
            1. Review the violations listed above with file names and line numbers
            2. Remove or generalize organization-specific content
            3. Replace any hardcoded secrets with GitHub Secrets
            4. Update internal references to public equivalents

            ### üìö Resources
            - [Two-Tier Architecture](docs/TWO_TIER_ARCHITECTURE.md)
            - [Standards Coordination](STANDARDS_COORDINATION.md)
            - [Private Repository Reference](docs/guide/PRIVATE_REPOSITORY_REFERENCE.md)

            ### ‚úÖ Resolution
            Once violations are addressed, this issue will be automatically closed on the next successful scan.

            ---
            *This issue was automatically created by the Confidentiality Scan workflow.*
            `;

            // Check for existing open issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'confidentiality-violation',
              per_page: 1
            });

            if (issues.data.length > 0) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `### üîÑ New Violations Detected\n\n${body}`
              });
              console.log(`Updated existing issue #${issues.data[0].number}`);
            } else {
              // Create new issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[Security] Confidentiality Scan Violations - ${new Date().toISOString().split('T')[0]}`,
                body: body,
                labels: ['security', 'confidentiality-violation', 'automation'],
                assignees: ['copilot', 'jmiller-moko']
              });
              console.log(`Created new issue #${issue.data.number}`);
            }

      - name: Fail if violations found
        if: steps.org_scan.outcome == 'failure' || steps.secret_scan.outcome == 'failure'
        run: |
          set -x
          echo "‚ùå Confidentiality scan failed due to violations"
          echo "Review the check run and PR comment for details"
          exit 1
